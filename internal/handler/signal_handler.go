package handler

import (
	"context"

	"dahlia/commons/error_handler"
	"dahlia/commons/handler"
	executor "dahlia/internal/consumer/executor_queue/iface"
	"dahlia/internal/domain"
	"dahlia/internal/dto"
	"dahlia/internal/logger"
	"dahlia/internal/repository/dynamodb"
	repositoryIface "dahlia/internal/repository/iface"
	"dahlia/internal/service"
)

type SignalHandler struct {
	logger        logger.Logger
	signalRepo    repositoryIface.SignalRepository
	workflowMgr   service.WorkflowManager
	executorQueue executor.ExecutorConsumer
}

func NewSignalHandler(
	log logger.Logger,
	signalRepo repositoryIface.SignalRepository,
	workflowMgr service.WorkflowManager,
	executorQueue executor.ExecutorConsumer,
) *SignalHandler {
	return &SignalHandler{
		logger:        log.With(logger.String("component", "signal_handler")),
		signalRepo:    signalRepo,
		workflowMgr:   workflowMgr,
		executorQueue: executorQueue,
	}
}

func (h *SignalHandler) CreateSignalService(
	ctx context.Context,
	ioutil *handler.RequestIo[dto.CreateSignalRequest],
) (dto.CreateSignalResponse, *error_handler.ErrorCollection) {
	req := ioutil.Body

	// Create signal (in memory)
	signal := domain.NewSignal(req.SignalType, req.OrgID, req.Value, req.Metadata, req.Timestamp)

	// Find matching workflows first
	workflows, err := h.workflowMgr.GetWorkflowsBySignalType(ctx, signal.SignalType)
	if err != nil {
		h.logger.Error("failed to get workflows",
			logger.String("signal_type", signal.SignalType),
			logger.String("error", err.Error()),
		)
		// Return error since we couldn't find workflows
		return dto.CreateSignalResponse{}, error_handler.NewErrorCollection().
			AddError(error_handler.CodeInternalServerError, "failed to get workflows", err.Error())
	}

	// Filter to get only the latest version of each workflow
	latestWorkflows := h.filterLatestVersions(workflows)

	// Queue workflows for execution BEFORE saving signal
	queuedCount := 0
	for _, workflow := range latestWorkflows {
		msg := executor.ExecutorMessage{
			SignalID:        signal.SignalID,
			WorkflowID:      workflow.WorkflowID,
			WorkflowVersion: workflow.Version,
			RunID:           "", // Will be generated by executor
			ResumeFrom:      "", // Initial run
		}

		if err := h.executorQueue.SendMessage(ctx, msg); err != nil {
			h.logger.Error("failed to queue workflow",
				logger.String("signal_id", signal.SignalID),
				logger.String("workflow_id", workflow.WorkflowID),
				logger.Int("version", workflow.Version),
				logger.String("error", err.Error()),
			)
			continue
		}

		queuedCount++
	}

	// Now save signal to DynamoDB after queuing
	if err := h.signalRepo.Create(ctx, signal); err != nil {
		// Check if it's a duplicate signal
		if dynamodb.IsDuplicateSignalError(err) {
			// Get the existing signal to return its actual ID
			existingSignal, getErr := h.signalRepo.GetByID(ctx, signal.SignalID)
			if getErr != nil {
				h.logger.Error("failed to get existing duplicate signal",
					logger.String("signal_id", signal.SignalID),
					logger.Error(getErr))
				// Even if we can't get it, return success with the computed ID
				existingSignal = signal
			}

			h.logger.Info("duplicate signal ignored",
				logger.String("signal_type", signal.SignalType),
				logger.String("org_id", signal.OrgID),
				logger.String("timestamp", signal.Timestamp),
				logger.String("existing_signal_id", existingSignal.SignalID),
				logger.Int("workflows_already_queued", queuedCount),
			)
			// Return success for duplicate signals with existing signal ID
			// This prevents duplicate processing while maintaining idempotency
			return dto.CreateSignalResponse{
				SignalID:        existingSignal.SignalID,
				WorkflowsQueued: queuedCount,
			}, nil
		}

		h.logger.Error("failed to save signal to DynamoDB",
			logger.String("signal_id", signal.SignalID),
			logger.Int("workflows_already_queued", queuedCount),
			logger.String("error", err.Error()),
		)
		// Note: Workflows are already queued, but signal save failed
		// This is acceptable - workflows will process even without signal record
		return dto.CreateSignalResponse{}, error_handler.NewErrorCollection().
			AddError(error_handler.CodeInternalServerError, "failed to save signal", err.Error())
	}

	return dto.CreateSignalResponse{
		SignalID:        signal.SignalID,
		WorkflowsQueued: queuedCount,
	}, nil
}

// filterLatestVersions filters workflows to return only the latest version of each workflow
func (h *SignalHandler) filterLatestVersions(workflows []*domain.Workflow) []*domain.Workflow {
	// Map to track the latest version of each workflow
	latestVersionMap := make(map[string]*domain.Workflow)

	for _, workflow := range workflows {
		existing, found := latestVersionMap[workflow.WorkflowID]

		// If this is the first time seeing this workflow, or if this version is higher
		if !found || workflow.Version > existing.Version {
			latestVersionMap[workflow.WorkflowID] = workflow
		}
	}

	// Convert map to slice
	result := make([]*domain.Workflow, 0, len(latestVersionMap))
	for _, workflow := range latestVersionMap {
		result = append(result, workflow)
	}

	return result
}
